{
  "patterns": [
    {
      "id": "shopping-cart",
      "title": "Shopping Cart Implementation",
      "description": "State management patterns for e-commerce carts",
      "category": "E-commerce",
      "difficulty": "intermediate",
      "concepts": ["State management", "Local storage", "Computed values"],
      "react": {
        "code": "// React Shopping Cart with Context API\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\n\nconst CartContext = createContext();\n\nconst cartReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const existingItem = state.items.find(item => item.id === action.payload.id);\n      if (existingItem) {\n        return {\n          ...state,\n          items: state.items.map(item =>\n            item.id === action.payload.id\n              ? { ...item, quantity: item.quantity + 1 }\n              : item\n          )\n        };\n      }\n      return {\n        ...state,\n        items: [...state.items, { ...action.payload, quantity: 1 }]\n      };\n    case 'REMOVE_ITEM':\n      return {\n        ...state,\n        items: state.items.filter(item => item.id !== action.payload)\n      };\n    case 'UPDATE_QUANTITY':\n      return {\n        ...state,\n        items: state.items.map(item =>\n          item.id === action.payload.id\n            ? { ...item, quantity: action.payload.quantity }\n            : item\n        )\n      };\n    default:\n      return state;\n  }\n};\n\nexport function CartProvider({ children }) {\n  const [state, dispatch] = useReducer(cartReducer, {\n    items: JSON.parse(localStorage.getItem('cart') || '[]')\n  });\n\n  useEffect(() => {\n    localStorage.setItem('cart', JSON.stringify(state.items));\n  }, [state.items]);\n\n  const cartTotal = state.items.reduce(\n    (total, item) => total + item.price * item.quantity,\n    0\n  );\n\n  const cartCount = state.items.reduce(\n    (count, item) => count + item.quantity,\n    0\n  );\n\n  return (\n    <CartContext.Provider value={{\n      items: state.items,\n      total: cartTotal,\n      count: cartCount,\n      addItem: (item) => dispatch({ type: 'ADD_ITEM', payload: item }),\n      removeItem: (id) => dispatch({ type: 'REMOVE_ITEM', payload: id }),\n      updateQuantity: (id, quantity) => \n        dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } })\n    }}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nexport const useCart = () => useContext(CartContext);",
        "usage": "// Using the cart in a component\nfunction ProductCard({ product }) {\n  const { addItem } = useCart();\n  \n  return (\n    <div className=\"product-card\">\n      <h3>{product.name}</h3>\n      <p>${product.price}</p>\n      <button onClick={() => addItem(product)}>\n        Add to Cart\n      </button>\n    </div>\n  );\n}"
      },
      "vue": {
        "code": "// Vue Shopping Cart with Pinia\nimport { defineStore } from 'pinia'\nimport { computed, ref, watch } from 'vue'\n\nexport const useCartStore = defineStore('cart', () => {\n  const items = ref(JSON.parse(localStorage.getItem('cart') || '[]'))\n  \n  const total = computed(() => \n    items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)\n  )\n  \n  const count = computed(() => \n    items.value.reduce((sum, item) => sum + item.quantity, 0)\n  )\n  \n  function addItem(product) {\n    const existingItem = items.value.find(item => item.id === product.id)\n    \n    if (existingItem) {\n      existingItem.quantity++\n    } else {\n      items.value.push({ ...product, quantity: 1 })\n    }\n  }\n  \n  function removeItem(productId) {\n    const index = items.value.findIndex(item => item.id === productId)\n    if (index > -1) {\n      items.value.splice(index, 1)\n    }\n  }\n  \n  function updateQuantity(productId, quantity) {\n    const item = items.value.find(item => item.id === productId)\n    if (item) {\n      item.quantity = quantity\n    }\n  }\n  \n  // Persist to localStorage\n  watch(items, (newItems) => {\n    localStorage.setItem('cart', JSON.stringify(newItems))\n  }, { deep: true })\n  \n  return {\n    items: computed(() => items.value),\n    total,\n    count,\n    addItem,\n    removeItem,\n    updateQuantity\n  }\n})",
        "usage": "<!-- Using the cart in a component -->\n<template>\n  <div class=\"product-card\">\n    <h3>{{ product.name }}</h3>\n    <p>${{ product.price }}</p>\n    <button @click=\"cartStore.addItem(product)\">\n      Add to Cart\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { useCartStore } from '@/stores/cart'\n\nconst props = defineProps(['product'])\nconst cartStore = useCartStore()\n</script>"
      },
      "keyDifferences": [
        "Vue's reactivity automatically tracks dependencies",
        "React requires explicit dispatch actions",
        "Vue's computed properties are cached automatically",
        "React needs useMemo for similar optimization"
      ]
    },
    {
      "id": "product-filter",
      "title": "Product Filtering & Search",
      "description": "Advanced filtering with multiple criteria",
      "category": "E-commerce",
      "difficulty": "intermediate",
      "concepts": ["Computed properties", "Performance optimization", "Debouncing"],
      "react": {
        "code": "// React Product Filter\nimport React, { useState, useMemo, useCallback } from 'react';\nimport { debounce } from 'lodash';\n\nfunction ProductFilters({ products }) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState('all');\n  const [priceRange, setPriceRange] = useState([0, 1000]);\n  const [sortBy, setSortBy] = useState('name');\n\n  // Debounced search\n  const debouncedSearch = useCallback(\n    debounce((term) => setSearchTerm(term), 300),\n    []\n  );\n\n  // Get unique categories\n  const categories = useMemo(() => {\n    const cats = new Set(products.map(p => p.category));\n    return ['all', ...Array.from(cats)];\n  }, [products]);\n\n  // Filter and sort products\n  const filteredProducts = useMemo(() => {\n    let filtered = products;\n\n    // Search filter\n    if (searchTerm) {\n      filtered = filtered.filter(product =>\n        product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n        product.description.toLowerCase().includes(searchTerm.toLowerCase())\n      );\n    }\n\n    // Category filter\n    if (selectedCategory !== 'all') {\n      filtered = filtered.filter(product => \n        product.category === selectedCategory\n      );\n    }\n\n    // Price filter\n    filtered = filtered.filter(product => \n      product.price >= priceRange[0] && product.price <= priceRange[1]\n    );\n\n    // Sort\n    return filtered.sort((a, b) => {\n      switch (sortBy) {\n        case 'price-asc':\n          return a.price - b.price;\n        case 'price-desc':\n          return b.price - a.price;\n        case 'name':\n        default:\n          return a.name.localeCompare(b.name);\n      }\n    });\n  }, [products, searchTerm, selectedCategory, priceRange, sortBy]);\n\n  return (\n    <div className=\"product-filters\">\n      <div className=\"filters\">\n        <input\n          type=\"text\"\n          placeholder=\"Search products...\"\n          onChange={(e) => debouncedSearch(e.target.value)}\n        />\n        \n        <select \n          value={selectedCategory}\n          onChange={(e) => setSelectedCategory(e.target.value)}\n        >\n          {categories.map(cat => (\n            <option key={cat} value={cat}>\n              {cat.charAt(0).toUpperCase() + cat.slice(1)}\n            </option>\n          ))}\n        </select>\n\n        <select\n          value={sortBy}\n          onChange={(e) => setSortBy(e.target.value)}\n        >\n          <option value=\"name\">Name</option>\n          <option value=\"price-asc\">Price: Low to High</option>\n          <option value=\"price-desc\">Price: High to Low</option>\n        </select>\n      </div>\n\n      <div className=\"results\">\n        <p>{filteredProducts.length} products found</p>\n        <div className=\"product-grid\">\n          {filteredProducts.map(product => (\n            <ProductCard key={product.id} product={product} />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}",
        "usage": "// App component\nfunction App() {\n  const [products] = useState([\n    { id: 1, name: 'Laptop', category: 'electronics', price: 999 },\n    { id: 2, name: 'Shirt', category: 'clothing', price: 29 },\n    // ... more products\n  ]);\n\n  return <ProductFilters products={products} />;\n}"
      },
      "vue": {
        "code": "// Vue Product Filter\n<template>\n  <div class=\"product-filters\">\n    <div class=\"filters\">\n      <input\n        v-model=\"searchTerm\"\n        type=\"text\"\n        placeholder=\"Search products...\"\n      >\n      \n      <select v-model=\"selectedCategory\">\n        <option value=\"all\">All Categories</option>\n        <option \n          v-for=\"cat in categories\" \n          :key=\"cat\"\n          :value=\"cat\"\n        >\n          {{ capitalize(cat) }}\n        </option>\n      </select>\n\n      <select v-model=\"sortBy\">\n        <option value=\"name\">Name</option>\n        <option value=\"price-asc\">Price: Low to High</option>\n        <option value=\"price-desc\">Price: High to Low</option>\n      </select>\n\n      <div class=\"price-range\">\n        <input \n          v-model.number=\"priceRange[0]\" \n          type=\"number\" \n          placeholder=\"Min price\"\n        >\n        <input \n          v-model.number=\"priceRange[1]\" \n          type=\"number\" \n          placeholder=\"Max price\"\n        >\n      </div>\n    </div>\n\n    <div class=\"results\">\n      <p>{{ filteredProducts.length }} products found</p>\n      <div class=\"product-grid\">\n        <ProductCard\n          v-for=\"product in filteredProducts\"\n          :key=\"product.id\"\n          :product=\"product\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, watch } from 'vue'\nimport { debounce } from 'lodash'\nimport ProductCard from './ProductCard.vue'\n\nconst props = defineProps(['products'])\n\nconst searchTerm = ref('')\nconst selectedCategory = ref('all')\nconst priceRange = ref([0, 1000])\nconst sortBy = ref('name')\n\n// Debounced search term\nconst debouncedSearchTerm = ref('')\nconst updateSearch = debounce((value) => {\n  debouncedSearchTerm.value = value\n}, 300)\n\nwatch(searchTerm, updateSearch)\n\n// Get unique categories\nconst categories = computed(() => {\n  const cats = new Set(props.products.map(p => p.category))\n  return Array.from(cats)\n})\n\n// Filter and sort products\nconst filteredProducts = computed(() => {\n  let filtered = props.products\n\n  // Search filter\n  if (debouncedSearchTerm.value) {\n    const search = debouncedSearchTerm.value.toLowerCase()\n    filtered = filtered.filter(product =>\n      product.name.toLowerCase().includes(search) ||\n      product.description.toLowerCase().includes(search)\n    )\n  }\n\n  // Category filter\n  if (selectedCategory.value !== 'all') {\n    filtered = filtered.filter(product => \n      product.category === selectedCategory.value\n    )\n  }\n\n  // Price filter\n  filtered = filtered.filter(product => \n    product.price >= priceRange.value[0] && \n    product.price <= priceRange.value[1]\n  )\n\n  // Sort\n  return filtered.slice().sort((a, b) => {\n    switch (sortBy.value) {\n      case 'price-asc':\n        return a.price - b.price\n      case 'price-desc':\n        return b.price - a.price\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name)\n    }\n  })\n})\n\nconst capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1)\n</script>",
        "usage": "<!-- Parent component -->\n<template>\n  <ProductFilters :products=\"products\" />\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport ProductFilters from './ProductFilters.vue'\n\nconst products = ref([\n  { id: 1, name: 'Laptop', category: 'electronics', price: 999 },\n  { id: 2, name: 'Shirt', category: 'clothing', price: 29 },\n  // ... more products\n])\n</script>"
      },
      "keyDifferences": [
        "Vue's v-model provides two-way binding automatically",
        "React requires manual onChange handlers",
        "Vue computed properties recalculate only when dependencies change",
        "React useMemo requires explicit dependency arrays"
      ]
    },
    {
      "id": "checkout-flow",
      "title": "Multi-Step Checkout Process",
      "description": "Complex form handling with validation",
      "category": "E-commerce",
      "difficulty": "advanced",
      "concepts": ["Form validation", "Multi-step forms", "State persistence"],
      "react": {
        "code": "// React Multi-Step Checkout\nimport React, { useState, createContext, useContext } from 'react';\n\nconst CheckoutContext = createContext();\n\nconst steps = [\n  { id: 'shipping', title: 'Shipping Information' },\n  { id: 'payment', title: 'Payment Method' },\n  { id: 'review', title: 'Review Order' }\n];\n\nfunction CheckoutProvider({ children }) {\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState({\n    shipping: {\n      firstName: '',\n      lastName: '',\n      email: '',\n      address: '',\n      city: '',\n      zipCode: '',\n      country: ''\n    },\n    payment: {\n      cardNumber: '',\n      cardName: '',\n      expiryDate: '',\n      cvv: ''\n    }\n  });\n  const [errors, setErrors] = useState({});\n\n  const updateFormData = (section, data) => {\n    setFormData(prev => ({\n      ...prev,\n      [section]: { ...prev[section], ...data }\n    }));\n  };\n\n  const validateStep = (step) => {\n    const newErrors = {};\n    \n    if (step === 'shipping') {\n      const { firstName, lastName, email, address, city, zipCode } = formData.shipping;\n      if (!firstName) newErrors.firstName = 'First name is required';\n      if (!lastName) newErrors.lastName = 'Last name is required';\n      if (!email) newErrors.email = 'Email is required';\n      if (!address) newErrors.address = 'Address is required';\n      if (!city) newErrors.city = 'City is required';\n      if (!zipCode) newErrors.zipCode = 'Zip code is required';\n    }\n    \n    if (step === 'payment') {\n      const { cardNumber, cardName, expiryDate, cvv } = formData.payment;\n      if (!cardNumber) newErrors.cardNumber = 'Card number is required';\n      if (!cardName) newErrors.cardName = 'Cardholder name is required';\n      if (!expiryDate) newErrors.expiryDate = 'Expiry date is required';\n      if (!cvv) newErrors.cvv = 'CVV is required';\n    }\n    \n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const nextStep = () => {\n    const stepId = steps[currentStep].id;\n    if (validateStep(stepId)) {\n      setCurrentStep(prev => Math.min(prev + 1, steps.length - 1));\n    }\n  };\n\n  const prevStep = () => {\n    setCurrentStep(prev => Math.max(prev - 1, 0));\n  };\n\n  return (\n    <CheckoutContext.Provider value={{\n      currentStep,\n      steps,\n      formData,\n      errors,\n      updateFormData,\n      nextStep,\n      prevStep\n    }}>\n      {children}\n    </CheckoutContext.Provider>\n  );\n}\n\n// Shipping Step Component\nfunction ShippingStep() {\n  const { formData, errors, updateFormData } = useContext(CheckoutContext);\n  const { shipping } = formData;\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    updateFormData('shipping', { [name]: value });\n  };\n\n  return (\n    <div className=\"shipping-form\">\n      <h2>Shipping Information</h2>\n      <form>\n        <div className=\"form-row\">\n          <input\n            name=\"firstName\"\n            value={shipping.firstName}\n            onChange={handleChange}\n            placeholder=\"First Name\"\n            className={errors.firstName ? 'error' : ''}\n          />\n          {errors.firstName && <span className=\"error-msg\">{errors.firstName}</span>}\n        </div>\n        {/* More form fields... */}\n      </form>\n    </div>\n  );\n}",
        "usage": "// Main Checkout Component\nfunction Checkout() {\n  const { currentStep, steps, nextStep, prevStep } = useContext(CheckoutContext);\n\n  return (\n    <div className=\"checkout\">\n      <div className=\"progress-bar\">\n        {steps.map((step, index) => (\n          <div \n            key={step.id}\n            className={`step ${index <= currentStep ? 'active' : ''}`}\n          >\n            {step.title}\n          </div>\n        ))}\n      </div>\n\n      <div className=\"step-content\">\n        {currentStep === 0 && <ShippingStep />}\n        {currentStep === 1 && <PaymentStep />}\n        {currentStep === 2 && <ReviewStep />}\n      </div>\n\n      <div className=\"navigation\">\n        {currentStep > 0 && (\n          <button onClick={prevStep}>Previous</button>\n        )}\n        {currentStep < steps.length - 1 ? (\n          <button onClick={nextStep}>Next</button>\n        ) : (\n          <button onClick={submitOrder}>Place Order</button>\n        )}\n      </div>\n    </div>\n  );\n}"
      },
      "vue": {
        "code": "// Vue Multi-Step Checkout Store\nimport { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\n\nexport const useCheckoutStore = defineStore('checkout', () => {\n  const currentStep = ref(0)\n  const steps = [\n    { id: 'shipping', title: 'Shipping Information' },\n    { id: 'payment', title: 'Payment Method' },\n    { id: 'review', title: 'Review Order' }\n  ]\n  \n  const formData = ref({\n    shipping: {\n      firstName: '',\n      lastName: '',\n      email: '',\n      address: '',\n      city: '',\n      zipCode: '',\n      country: ''\n    },\n    payment: {\n      cardNumber: '',\n      cardName: '',\n      expiryDate: '',\n      cvv: ''\n    }\n  })\n  \n  const errors = ref({})\n  \n  const validateStep = (stepId) => {\n    const newErrors = {}\n    \n    if (stepId === 'shipping') {\n      const shipping = formData.value.shipping\n      if (!shipping.firstName) newErrors.firstName = 'First name is required'\n      if (!shipping.lastName) newErrors.lastName = 'Last name is required'\n      if (!shipping.email) newErrors.email = 'Email is required'\n      if (!shipping.address) newErrors.address = 'Address is required'\n      if (!shipping.city) newErrors.city = 'City is required'\n      if (!shipping.zipCode) newErrors.zipCode = 'Zip code is required'\n    }\n    \n    if (stepId === 'payment') {\n      const payment = formData.value.payment\n      if (!payment.cardNumber) newErrors.cardNumber = 'Card number is required'\n      if (!payment.cardName) newErrors.cardName = 'Cardholder name is required'\n      if (!payment.expiryDate) newErrors.expiryDate = 'Expiry date is required'\n      if (!payment.cvv) newErrors.cvv = 'CVV is required'\n    }\n    \n    errors.value = newErrors\n    return Object.keys(newErrors).length === 0\n  }\n  \n  const nextStep = () => {\n    const stepId = steps[currentStep.value].id\n    if (validateStep(stepId)) {\n      currentStep.value = Math.min(currentStep.value + 1, steps.length - 1)\n    }\n  }\n  \n  const prevStep = () => {\n    currentStep.value = Math.max(currentStep.value - 1, 0)\n  }\n  \n  const currentStepData = computed(() => steps[currentStep.value])\n  \n  return {\n    currentStep,\n    currentStepData,\n    steps,\n    formData,\n    errors,\n    nextStep,\n    prevStep,\n    validateStep\n  }\n})",
        "usage": "<!-- Checkout Component -->\n<template>\n  <div class=\"checkout\">\n    <div class=\"progress-bar\">\n      <div \n        v-for=\"(step, index) in checkoutStore.steps\"\n        :key=\"step.id\"\n        :class=\"['step', { active: index <= checkoutStore.currentStep }]\"\n      >\n        {{ step.title }}\n      </div>\n    </div>\n\n    <div class=\"step-content\">\n      <ShippingStep v-if=\"checkoutStore.currentStep === 0\" />\n      <PaymentStep v-if=\"checkoutStore.currentStep === 1\" />\n      <ReviewStep v-if=\"checkoutStore.currentStep === 2\" />\n    </div>\n\n    <div class=\"navigation\">\n      <button \n        v-if=\"checkoutStore.currentStep > 0\"\n        @click=\"checkoutStore.prevStep\"\n      >\n        Previous\n      </button>\n      <button \n        v-if=\"checkoutStore.currentStep < checkoutStore.steps.length - 1\"\n        @click=\"checkoutStore.nextStep\"\n      >\n        Next\n      </button>\n      <button \n        v-else\n        @click=\"submitOrder\"\n      >\n        Place Order\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { useCheckoutStore } from '@/stores/checkout'\nimport ShippingStep from './ShippingStep.vue'\nimport PaymentStep from './PaymentStep.vue'\nimport ReviewStep from './ReviewStep.vue'\n\nconst checkoutStore = useCheckoutStore()\n\nconst submitOrder = async () => {\n  // Submit order logic\n}\n</script>\n\n<!-- ShippingStep.vue -->\n<template>\n  <div class=\"shipping-form\">\n    <h2>Shipping Information</h2>\n    <form>\n      <div class=\"form-row\">\n        <input\n          v-model=\"shipping.firstName\"\n          placeholder=\"First Name\"\n          :class=\"{ error: errors.firstName }\"\n        >\n        <span v-if=\"errors.firstName\" class=\"error-msg\">\n          {{ errors.firstName }}\n        </span>\n      </div>\n      <!-- More form fields... -->\n    </form>\n  </div>\n</template>\n\n<script setup>\nimport { useCheckoutStore } from '@/stores/checkout'\nimport { computed } from 'vue'\n\nconst checkoutStore = useCheckoutStore()\nconst shipping = computed(() => checkoutStore.formData.shipping)\nconst errors = computed(() => checkoutStore.errors)\n</script>"
      },
      "keyDifferences": [
        "Vue's v-model simplifies form binding",
        "React requires explicit onChange handlers for each input",
        "Vue's reactive system automatically updates computed values",
        "React Context requires more boilerplate than Pinia"
      ]
    }
  ]
}